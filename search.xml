<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JDK各版本的新特性]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%2F2019-4-java-editon%2F</url>
    <content type="text"><![CDATA[好久没有更新微博了，话说今年经历的事情其实还是蛮多的。换了个新公司，然后又重新租了房子，相当于搬了一次家！新公司的工作还是蛮紧张的，很多业务还不熟，其实这都不应该成为我懒惰的理由~ 还是继续码字吧！嗯，码字使我快乐~ 今天就来说一下，JDK的发展历史和各版本的新特性。（最近喜欢上了历史，觉得历史真的很启发人生） JDK 背景java 诞生于1995年初期（这时候我还没有出生~），其实1991年由 James Gosling 率领的小组就已经在研发了，但直到1995年才出世，然后更名为java。打着 “Write Once,Run Anywhere” 的口号，随后一发不可收拾，一路风靡全球，解放了可爱的程序员们~ 祖师爷 JDK 1.0 Sun Classic VM（虚拟机） Applet（java小应用程序） AWT（java图形设计） JDK 1.1 JDBC（Java DataBase Connectivity）; Inner Class（支持内部类）; RMI(Remote Method Invocation) ; Reflection（反射）; JavaBeans（java规范）; JDK 1.2 Collections（集合框架） JIT（即时编译技术） Java Plug-In（运行插件） EJB（J2EE的规范） Java IDL（平台对象请求代理体系结构） 对打包的Java文件进行数字签名 控制授权访问系统资源的策略工具 JDBC中引入可滚动结果集,BLOB,CLOB,批量更新和用户自定义类型 在Applet中添加声音支持 JDK 1.3 数学运算 Timer API（时间） Java Sound API（声音） CORBA IIOP实现RMI的通信协议 Java 2D新特性 jar文件索引 JDK 1.4 正则表达式 异常链 NIO（高级流） Logging （日志功能） XML解析器 XSLT转换器 XML处理 Java打印服务 Java Web Start JDBC 3.0（jdbc高级） 断言 Preferences（可以操作系统的高级功能） IPV6 Imgae I/O（图片流） JDK 5 自动装箱拆箱 foreach 静态导入 enum（枚举） 格式化输出 可变长参数（Varargs） 泛型 元数据 Introspector（内省） JMM（内存模型） concurrent（并发包） JDK 6 命名方式变更 用Console开发控制台程序 脚本语言：对脚本语言的支持（如：ruby，groovy，javascript） Compiler API 轻量级 Http Server API 锁与同步 垃圾收集 类加载 JDBC 4.0（jdbc高级） Java Compiler （Java™ 编程语言编译器的接口） 可插拔注解 Native PKI(公钥基础设) Java GSS （通用安全服务） Kerberos （ 一种安全认证的系统） LDAP （LDAP ） Web Services （web服务） JDK 7 二进制字面值：数值类型可以用二进制字符串表示 switch 语句支持 String：switch语句块中允许以字符串作为分支条件 类型推断：创建泛型对象时应用类型推断 try-with-resources：自动关闭流 catch 多个类型异常：一个语句块中捕获多种异常 null值得自动处理 引入Java NIO.2开发包 动态语言支持 安全的加减乘除 Map集合支持并发请求 JDK 8 Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中）。 函数式接口 增强类型推断 重复注解和类型注解 方法引用 、构造器引用和数组引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 接口支持默认方法和静态方法− 默认方法就是一个在接口里面有了一个实现的方法。 新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。 Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。 Date Time API − 新的日期时间 API，加强对日期与时间的处理。 Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。 Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。 JDK 9 目录结构 模块化系统：模块是一个包的容器，Java 9 最大的变化之一是引入了模块系统（Jigsaw 项目）。 REPL (JShell)：交互式编程环境。 HTTP 2 客户端：HTTP/2标准是HTTP协议的最新版本，新的 HTTPClient API 支持 WebSocket 和 HTTP2 流以及服务器推送特性。 改进的 Javadoc：Javadoc 现在支持在 API 文档中的进行搜索。另外，Javadoc 的输出现在符合兼容 HTML5 标准。 多版本兼容 JAR 包：多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本。 集合工厂方法：List，Set 和 Map 接口中，新的静态工厂方法可以创建这些集合的不可变实例。 接口的私有方法：在接口中使用private私有方法。我们可以使用 private 访问修饰符在接口中编写私有方法。 进程 API: 改进的 API 来控制和管理操作系统进程。引进 java.lang.ProcessHandle 及其嵌套接口 Info 来让开发者逃离时常因为要获取一个本地进程的 PID 而不得不使用本地代码的窘境。 增强Stream API：改进的 Stream API 添加了一些便利的方法，使流处理更容易，并使用收集器编写复杂的查询。 改进 try-with-resources：如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。 改进的弃用注解 @Deprecated：注解 @Deprecated 可以标记 Java API 状态，可以表示被标记的 API 将会被移除，或者已经破坏。 改进钻石操作符(Diamond Operator) ：匿名类可以使用钻石操作符(Diamond Operator)。改进 Optional 类：java.util.Optional 添加了很多新的有用方法，Optional 可以直接转为 stream。 多分辨率图像 API：定义多分辨率图像API，开发者可以很容易的操作和展示不同分辨率的图像了。 改进的 CompletableFuture API ： CompletableFuture 类的异步机制可以在 ProcessHandle.onExit 方法退出时执行操作。 轻量级的 JSON API：内置了一个轻量级的JSON API。 响应式流（Reactive Streams) API: Java 9中引入了新的响应式流 API 来支持 Java 9 中的响应式编程。 JDK 10 局部变量类型推断 将JDK多存储库合并为单储存库 垃圾回收接口 并行Full GC 的G1 应用数据共享 线程局部管控 移除Native-Header Generation Tool （javah） Unicode 标签扩展 备用内存设备上分配堆内存 基于实验JAVA 的 JIT 编译器 Root 证书 基于时间的版本控制 JDK 11 Nest-Based访问控制 动态类文件常量 改善Aarch64 intrinsic 无操作垃圾收集器 消除Java EE和CORBA模块 HTTP客户端(标准) 局部变量的语法λ参数 Curve25519和Curve448关键协议 Unicode 10 飞行记录器 ChaCha20和Poly1305加密算法 发射一列纵队源代码程序 低开销堆分析 传输层安全性(Transport Layer Security,TLS)1.3 动作:一个可伸缩的低延迟垃圾收集器 (实验) 反对Nashorn JavaScript引擎 反对Pack200工具和API JDK 12未完待续 JDK 13未完待续]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JDK</tag>
        <tag>新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说浏览器的跨域问题]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%2F2019-1-cors%2F</url>
    <content type="text"><![CDATA[由于最近一个项目，采用的是前后端分离的开发模式，故在项目尾声进行接口调试的时候，便出现了跨域的问题。于是在Google与百度上查阅了不少的博客及资料。现总结一下解决的思路与方法。 什么是跨域请求如果当前发起请求的域与该请求指向的资源所在的域不一样。就是一个跨域请求。例如：前端同事的机器地址是http://192.168.37.132:8080,我的机器地址 http://192.168.37.133:8081。 那么从他的电脑发起向我的电脑的数据请求就是一个跨域请求。如果从我的本机 http://localhost:8081 发起向后台 http://localhost:8081 的请求就是一个同源请求。这里的域指的是这样的一个概念：协议 + 域名 + 端口号均相同，那么就是同域。否则是跨域。 浏览器对跨域做出的限制正常的请求后台是可以返回接口数据的。但是如果是跨域请求，则后台接口数据是无法正确返回的，这时浏览器会报一个跨域错误。No ‘Access-Control-Allow-Origin’ header is present on the requested resource。这是因为浏览器对跨域请求作出了限制。那么浏览器为什么要对跨域请求作出限制呢？其实主要是出于安全方面的考虑，因为跨域请求有可能被不法分子利用来发动 CSRF(跨站请求伪造)攻击。具体什么是CSRF？请自行百度一下。目前我们只需要知道跨域请求会带来安全问题，所以浏览器会限制它的发生。具体如何解决，请看下文。 跨域解决方法虽然在安全层面上跨域限制是必要的，但有时我们又需要发送跨域请求，比如我上面公司的项目遇到的情况。所以就需要绕开浏览器跨域的限制。方法有许多种，适应各种不同的情况。比如前端的话可以给请求加个代理。或者使用 JSONP, CORS 方法。下面就介绍一下 CORS 是如何解决跨域的。 跨域资源共享CORSCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest 请求。可以很好的解决 Ajax 只能同源使用的限制。CORS新增了一组HTTP首部字段。只要浏览器发现是跨域请求，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 下面是CORS中新增的HTTP首部字段： Origin //该首部字段表明预检请求或实际请求的源站。不管是否为跨域请求，Origin字段都会被发送。浏览器自行携带该字段。 Access-Control-Request-Method //该首部字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。浏览器自行携带该字段。 Access-Control-Request-Headers //该首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。浏览器自行携带该字段。 Access-Control-Allow-Origin //表示服务器允许哪些域可以访问该资源，配置在服务端。 Access-Control-Allow-Methods //表示服务器所允许的实际请求中使用的HTTP方法，配置在服务端。 Access-Control-Allow-Headers //该首部字段用于预检请求的响应。指明了实际请求中允许携带的首部字段，配置在服务端。 Access-Control-Max-Age //该首部字段用于预检请求的响应，指定了预检请求能够被缓存多久，配置在服务端。 Access-Control-Allow-Credentials //表示是否允许发送Cookie，配置在服务端。 Access-Control-Expose-Headers //表示如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。 CORS的两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。简单请求不会触发CORS预检请求。相反，非简单请求则会触发预检请求。就是我们所说的二次请求。 简单请求（1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 同时满足以上两种条件的即为简单请求。对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段（跨域的时候get，post都会显示origin，同域的时候get不显示origin，post显示origin）。上面的头信息中，Origin 字段用来说明，本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，No ‘Access-Control-Allow-Origin’ header is present on the requested resource。被XMLHttpRequest的onerror回调函数捕获。 后台添加注解支持跨域请求在类上123456@CrossOrigin(origins = &quot;http://api.bob.com&quot;, maxAge = 3600)@RestController@RequestMapping(&quot;/account&quot;)public class AccountController &#123; // ...&#125; 在方法上12345@CrossOrigin(origins = &quot;http://api.bob.com&quot;)@GetMapping(&quot;/&#123;id&#125;&quot;)public Account retrieve(@PathVariable Long id) &#123; // ...&#125; 添加注解后，服务器返回的响应，会多出几个头信息字段。 非简单请求非简单请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json，或者加了自定义头部信息的请求。非简单请求会发送两次请求，第一成为预检请求，第二次才是正常的跨域请求。 1.预检请求非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。”预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。除了Origin字段，”预检”请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method 该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 （2）Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 2.预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 后台可以增加一个过滤器，过滤所有的预检请求123456789101112131415161718192021@Overridepublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response =(HttpServletResponse)servletResponse; String token = request.getHeader(&quot;access_token&quot;); System.out.println(&quot;filter access_token:&quot;+token); //预检请求 if (&quot;OPTIONS&quot;.equals(request.getMethod()))&#123; response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&quot;Access-Control-Allow-Credentials&quot;,&quot;true&quot;); response.setHeader(&quot;Access-Control-Allow-Methods&quot;,&quot;POST, GET, OPTIONS, DELETE, PUT, PATCH&quot;); response.setHeader(&quot;Access-Control-Allow-Headers&quot;,&quot;Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type,Authorization,X-Custom-Header&quot;); response.setHeader(&quot;Access-Control-Max-Age&quot;,&quot;3600&quot;); response.setStatus(HttpStatus.OK.value()); &#125; filterChain.doFilter(servletRequest, servletResponse);&#125; 下面是通过预检请求的回应。如果预检请求没有通过，会触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 3.第二次请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 第二次请求 请求的正确回应]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在新年]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F2019-3-new-year%2F</url>
    <content type="text"><![CDATA[今天是2018年最后一天的日子。下午和老同学一起吃了个火锅，很舒服~。毕竟冬天与火锅更配哦！吃完饭看着外滩的人山人海，我们一致决定回去休息，就不凑这个热闹了，哈哈。。 其实2018年一整年，自己变化还是挺大的。感觉自己有变得更加自律（我就不客气了\^o^/ ）。还有工作和生活总算有点起色，可能是来到上海的原因吧。压力的确可以逼迫一个人成长（好像把自己说的很苦逼的样子）…。我觉得自己最大的收获就是总算找到一个可以继续努力的目标。时间很紧张，但却很充实。遗憾的就是时间过的太快，好多事情还没有做！比如：去各地旅游啊、写满一百篇博客啦（目前好像只有50多篇(╯^╰〉）。其实最近几天才刚搭好的个人博客网站（比计划时间要晚了很多，但总算是赶在19年之前弄好了(∩_∩)），准备不足，还有很多地方没有优化，请各位看官见谅。。总体来说，2018年算是我的一个转折点，有在走向好的一面！ 2019年可能不会是很容易的一年，但我很期待自己的表现。还有希望父母身体健康，自己工作可以有进步，然后运气爆棚^o^，加油！ 附一张我今天拍的夕阳~^o^~]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>新年</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo+GitHup搭建个人博客]]></title>
    <url>%2FHexo%2F2019-2-hexo%2F</url>
    <content type="text"><![CDATA[其实一直以来都有个想法，就是写个自己的博客网站，用来记录一些平时累积的技术和生活中的零碎想法。偶然间发现了一个好用的博客生成插件–Hexo。官网地址：https://hexo.io/zh-cn/本站所使用Next主题：https://github.com/theme-next 安装步骤参见 https://www.cnblogs.com/fengxiongZz/p/7707219.html 主题优化参见 http://theme-next.iissnan.com/参见 https://www.jianshu.com/p/f054333ac9e6 网上已经有很多很详细的安装使用教程了，所以本文就不在另起炉灶（就算再写也不一定有上面的博主写的好 →_→ ）。这里只提一下注意事项： 安装git客户端时，选第二或者第三个选项。 与GitHub关联时注意项目名与注册的GitHub账户名称要一样 如果出现输入 hexo d -g 没反应。原因：没加空格]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
